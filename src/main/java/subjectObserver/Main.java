package subjectObserver;


/**
 * 观察者模式    优点： 1.当两个对象之间松耦合，他们依然可以交互，但是不太清楚彼此的细节，观察者模式提供了一种对象设计，
 *                      让主题和观察者之间松耦合。主题所知道的这事一个具体的观察者列表，每一个具体观察者都符合一个抽象
 *                      观察者的接口。主题并不认识任何一个具体的观察者，它只知道他们又一个公共的接口。
 *                      2.观察者模式支持“广播通信”，主题会向所有的观察者发出通知。
 *                      3.观察者模式符合“开闭原则”的要求。
 *               缺点：  1.如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多的时间
 *                      2.如果在观察者和观察目标之间有循环依赖的话，观察目标会触发他们之间进行循环调用，可能导致系统崩溃。
 *                      3.观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。
 *
 *               使用场景：1.一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使用它们可以
 *                          各自独立地改变和复用。
 *                         2.一个对象的改变将导致其他一个或多个对象也发生变化，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
 *                         3.一个对象必须通知其他对象，而并不知道这些对象是谁，需要在系统中创建一个触发链，A对象的行为将影响B对象，
 *                         B对象的行为将影响C对象....，可以使用观察者模式创建一种链式触发机制。
 *               总结
 *                  1.观察者模式定义了对象之间的一对多关系。多个观察者监听同一个被观察者，当被观察者的状态发生改变时，会通知所有的观察者。
 *                  2.观察者模式中包含四个角色。主题，他指被观察的对象。具体主题是主题子类，通常他包含有经常发生改变的数据，当他
 *                  的状态发生改变时，向他的各个观察者发出通知；观察者，将对观察主题的改变做出反应；具体观察者中维护一个指向具体目标对象的
 *                  一用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。
 *                  3.主题用一个共同的接口来更新观察者。
 *                  4.观察者与被观察者之间用松耦合方式结合。
 *                  5.有多个观察者，不可以依赖特定的通知次序。
 *                  6.使用观察者模式，可以从被观察者处推或者拉数据。
 *                  参考资料：http://www.cnblogs.com/chenssy/archive/2013/05/22/3092071.html
 *
 *
 */
public class Main {
    public static void main(String[] args) {
        WeatherData weatherData = new WeatherData();
        CurrentCondituonDisplay currentCondituonDisplay = new CurrentCondituonDisplay(weatherData);

        weatherData.setMeasurements(80, 65, 30.4f);
        weatherData.setMeasurements(82, 70, 29.2f);
        weatherData.setMeasurements(78, 78, 40.4f);
    }
}
